JDK中用Thread.State类定义了线程的几种状态

新建到就绪  new 一个对象，并调用start方法。（调用完start方法，cpu未必执行该线程）

      调用start()                获取cpu的执行权
新建--------------------->就绪  ----------------->运 行  ------------------------->死亡
                               <-----------------       执行完run()；调用栈的stop()
                               失去cpu的执行权或yield（）  出现error或EXception
                                                        且没处理


yield:使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。
      但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。

阻塞不是一最终种状态。
运行到阻塞 sleep(long time)、join()、等待同步锁、suspend()[挂起]
阻塞到运行 sleep时间到、join()结束、获取同步锁、notify()/notifyAll()、resume()

问题的提出
多个线程执行的不确定性引起执行结果的不稳定
多个线程对账本的共享，会造成操作的不完整性，会破坏数据

因为出现共享的数据